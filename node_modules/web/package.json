{
  "_args": [
    [
      {
        "raw": "web",
        "scope": null,
        "escapedName": "web",
        "name": "web",
        "rawSpec": "",
        "spec": "latest",
        "type": "tag"
      },
      "/Users/aidandonnelly/Desktop/FINAL YEAR/HousingProject/node_modules"
    ]
  ],
  "_from": "web@latest",
  "_id": "web@0.0.2",
  "_inCache": true,
  "_location": "/web",
  "_npmUser": {
    "name": "creationix",
    "email": "tim@creationix.com"
  },
  "_npmVersion": "1.2.2",
  "_phantomChildren": {},
  "_requested": {
    "raw": "web",
    "scope": null,
    "escapedName": "web",
    "name": "web",
    "rawSpec": "",
    "spec": "latest",
    "type": "tag"
  },
  "_requiredBy": [
    "#USER",
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/web/-/web-0.0.2.tgz",
  "_shasum": "d9e227387306db8c4b239f0f4bae7fc14b4c117a",
  "_shrinkwrap": null,
  "_spec": "web",
  "_where": "/Users/aidandonnelly/Desktop/FINAL YEAR/HousingProject/node_modules",
  "author": {
    "name": "Tim Caswell"
  },
  "bugs": {
    "url": "https://github.com/creationix/node-web/issues"
  },
  "dependencies": {},
  "description": "A small and fast web/http library for nodejs. (replaces the built-in http module)",
  "devDependencies": {},
  "directories": {},
  "dist": {
    "shasum": "d9e227387306db8c4b239f0f4bae7fc14b4c117a",
    "tarball": "https://registry.npmjs.org/web/-/web-0.0.2.tgz"
  },
  "homepage": "https://github.com/creationix/node-web#readme",
  "license": "MIT",
  "main": "web.js",
  "maintainers": [
    {
      "name": "creationix",
      "email": "tim@creationix.com"
    }
  ],
  "name": "web",
  "optionalDependencies": {},
  "readme": "# Web\n\nWeb is a new node module designed for building web applications.  It's intended to replace the built-in `http` module as well as middle-ware systems like connect and stack.\n\nAs the creator of the connect/stack interface, I've learned a lot over the years about what I could have done better.  Also the built-in `http` module in node itself has gotten bloated and complex since we've learned as we've gone on.  Features can be added a lot easier than they can be removed.  As a result, there are many different optional interfaces in the node HTTP interface.\n\nThe new interface for web app layers found in `web` is closer modeled after the ideas in wsgi, rack, jsgi, strata.js and friends.  This allows for easy module composition and a simple but powerful interface through which layers can work together to build a complex web application.\n\n## The Old Interface\n\nIn the old node interface as exposed by the `http` module, you create an HTTP server and pass it an HTTP request handler function.\n\nUsage looks like:\n\n```js\n// Old \"http\" handler interface built-in to node.js\nfunction handler(request, response) {\n  // request.method is \"GET\", \"PUT\", \"POST\", etc..\n  // request.url is \"/foo/bar?and=stuff\" ...\n  // and other interesting properties.\n  // Also request itself is a readable node stream\n  // representing the http request body.\n\n  // response.writeHead(code, headers)\n  // response.write(data)\n  // response.end(optionalData)\n  // and *many* other interfaces and alternate methods for setting\n  // headers and code.\n  // also the response object is a writable node stream representing\n  // the response body.\n}\n\n// Create a TCP server that parses HTTP protocol and\n// calls the handler function on each request.\nvar server = http.createServer(handler);\nserver.listen(8080);\n```\n\nThis interface alone is not easy to wrap application layers and so middle-ware dispatchers like connect and stack were invented to ease the pain.  They still have several problems however.\n\nConsidering it's history, this module has a pretty good API, but there is only so much you can do if you're learning as you go and are unable to break backwards compatibility.  Cruft will accumulate even under the watchful eye of the best maintainers.\n\n## The New Way\n\nThe new interface is changed slightly.\n\nFirstly, instead of a `response` object that's both response stream and object full of random methods, there is a `respond` function that accepts status code, headers, and body.\n\nSecond, it's not bound to the `net` module anymore.  I believe that parsing HTTP and listening on a real network socket should be two different responsibilities.  If you separate the two, then it's much easier to create mock servers that listen on fake sockets or exotic real servers that aren't TCP based.\n\n```js\nvar app = function (request, respond) {\n  // request.method is \"GET\", \"POST\", \"PUT\", etc..\n  // request.url is the raw request path \"/foo/bar?and=stuff\"\n  // request.headers is the raw array of request headers.\n  // request.body is the request body as a stream.\n\n  // respond(code, headers, body) is a function\n  // body can be a string or a writable stream.\n}\n\n// This handler function expects a raw TCP connection\n// It handles HTTP parsing internally\nvar handler = require('web').socketHandler(app);\n\n// To serve the HTTP app over TCP, we only need to connect to a TCP server.\nvar server = require('net').createServer(handler);\nserver.listen(8080);\n```\n\n## Built-in Middleware System\n\nUnlike the `http` module, `web` makes it trivial to stack app layers.  There is no need for a library because all that's needed is a simple function.  Any function that implements the `(request, respond)` interface is a valid web application.\n\n### Basic Logger Layer\n\nSuppose you wanted to add a layer that logged all request and the response code the app gave them.\n\nThis can be done simple as:\n\n```js\nfunction logger(app) {\n  // Any per-layer startup logic would go here.\n  // We only need the app closure reference, so there is nothing else to do\n\n  return function(req, res) {\n\n    // Per request logic during the inward path would go here.  Since\n    // we want to wait till the response code is generated, there is nothing\n    // to do.\n\n    // Forward to the next layer inward.\n    app(req, function (code, headers, body) {\n\n      // Here we've intercepted the response function and can do stuff on the\n      // way back out of the layers.  We want to log the request and response.\n\n      console.log(req.method + \" \" + req.url.path + \" \" + code);\n\n      // Forward to the layers outward.\n      res(code, headers, body);\n    });\n  };\n}\n\n// Then to use this layer, we just wrap out app.\napp = logger(app);\n```\n\nAs you can see, there are places to do logic at several steps in a request and server lifetime.\n\n\n## Request Object\n\nThe request object contains the following properties.\n\n### req.method\n\nThis is the HTTP method in the request.  It can have values like \"GET\", \"POST\", \"PUT\", \"DELETE\", and any other value the node http parser supports.\n\n\n### req.headers\n\nThis is a hash of the headers with keys lowercases for easy access.\n\nIt can be used as:\n\n```js\nif (req.headers[\"content-type\"] === \"application/json\") { ... }\n```\n\n### req.url\n\nThis is the result of node's url.parse on the http request url.\n`req.url.path` contains the original raw string if desired.\n`req.url.pathname` is the path alone without query strings.\n\n### req.versionMajor, req.versionMinor\n\nThese two properties tell you the version of the http request.  They are usually either (1, 0) or (1, 1) for HTTP 1.0 and HTTP 1.1.\n\n### req.shouldKeepAlive\n\nThis is a hint set by node's http parser to tell the middleware if it should\nkeepalive the connection.\n\n### req.upgrade\n\nThis is another hint set by node's http parser.  It's true for upgrade request like websocket connections.\n\n\n### req.body\n\nThis property is set by the web library.  It's a readable node stream for the request body.\n\n### req.rawHeaders\n\nThis is a raw array of alternating key/value pairs.  For example, the headers from a curl request look like:\n\n```js\nreq.rawHeaders = [\n  'User-Agent', 'curl/7.26.0',\n  'Host',       'localhost:8080',\n  'Accept',     '*/*' ]\n```\n\n## Post response processing.\n\nThe built-in response function does a bit of post-processing after your app is\ndone to help your app be a proper http server.  These post-processing filters can be configured in the socketHandler function's options argument.\n\n### options.autoDate = true\n\nThis options adds a `Date` header with the current date as required by the HTTP spec if your response does not have a `Date` header.\n\n### options.autoServer = \"node.js \" + process.version\n\nAdds a `Server` header with the running version of node if you don't have a `Server` header.  Set to some falsy value to disable or set to a new string to replace.\n\n### options.autoContentLength = true\n\nIf your body is a known size (not streaming) and you leave out the `Content-Length` header, this will add one for you.\n\n### options.autoChunked = true\n\nIf you leave out a `Content-Length` header and your body is streaming, it will replace your stream with a chunked encoded stream and set the proper `Transfer-Encoding: chunked` header for you.\n\n### options.autoConnection = true\n\nThis will try to detect what the `Connection` header should be.  Usually either `close` or `keep-alive`.  Also it will update `req.shouldKeepAlive` which controls the tcp level connection behavior.\n\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git://github.com/creationix/node-web.git"
  },
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "version": "0.0.2"
}
