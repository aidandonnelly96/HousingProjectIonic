{"version":3,"sources":["../../../../src/database/observable/fromRef.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,UAAU,EAAE,MAAM,iBAAiB,CAAC;AAC7C,OAAO,EAAE,SAAS,EAAE,MAAM,yBAAyB,CAAC;AACpD,OAAO,EAAE,aAAa,EAAE,MAAM,cAAc,CAAC;AAC7C,OAAO,uBAAuB,CAAC;AAC/B,OAAO,yBAAyB,CAAC;AAOjC,MAAM,kBAAkB,GAAkB,EAAE,KAAkB,EAAE,UAAiB;IAAjB,2BAAA,EAAA,iBAAiB;IAC/E,IAAM,IAAI,GAAG,IAAI,UAAU,CAAqC,UAAA,UAAU;QACxE,IAAM,EAAE,GAAG,GAAG,CAAC,UAAU,CAAC,CAAC,KAAK,EAAE,UAAC,QAAQ,EAAE,OAAO;YAClD,UAAU,CAAC,IAAI,CAAC,EAAE,QAAQ,UAAA,EAAE,OAAO,SAAA,EAAE,CAAC,CAAA;QACxC,CAAC,EAAE,UAAU,CAAC,KAAK,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC;QACtC,MAAM,CAAC,EAAE,WAAW,gBAAK,GAAG,CAAC,GAAG,CAAC,KAAK,EAAE,EAAE,CAAC,CAAA,CAAA,CAAC,EAAE,CAAA;IAChD,CAAC,CAAC;SACD,GAAG,CAAC,UAAC,OAAwB;QACpB,IAAA,2BAAQ,EAAE,yBAAO,CAAa;QACtC,IAAI,GAAG,GAAkB,IAAI,CAAC;QAC9B,EAAE,CAAA,CAAC,QAAQ,CAAC,CAAC,CAAC;YAAC,GAAG,GAAG,QAAQ,CAAC,GAAG,CAAC;QAAC,CAAC;QACpC,MAAM,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,OAAO,EAAE,QAAQ,EAAE,OAAO,SAAA,EAAE,GAAG,KAAA,EAAE,CAAC;IAC1D,CAAC,CAAC;SAID,KAAK,CAAC,CAAC,CAAC,CAAC;IACV,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,aAAa,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC;AAC/D,CAAC","file":"fromRef.js","sourceRoot":"","sourcesContent":["import { DatabaseQuery, DatabaseSnapshot, ListenEvent, SnapshotPrevKey, AngularFireAction } from '../interfaces';\nimport { Observable } from 'rxjs/Observable';\nimport { observeOn } from 'rxjs/operator/observeOn';\nimport { ZoneScheduler } from 'angularfire2';\nimport 'rxjs/add/operator/map';\nimport 'rxjs/add/operator/delay';\n\n/**\n * Create an observable from a Database Reference or Database Query.\n * @param ref Database Reference\n * @param event Listen event type ('value', 'added', 'changed', 'removed', 'moved')\n */\nexport function fromRef(ref: DatabaseQuery, event: ListenEvent, listenType = 'on'): Observable<AngularFireAction<DatabaseSnapshot | null>> {\n  const ref$ = new Observable<SnapshotPrevKey | null | undefined>(subscriber => {\n    const fn = ref[listenType](event, (snapshot, prevKey) => {\n      subscriber.next({ snapshot, prevKey })\n    }, subscriber.error.bind(subscriber));\n    return { unsubscribe() { ref.off(event, fn)} }\n  })\n  .map((payload: SnapshotPrevKey) =>  { \n    const { snapshot, prevKey } = payload;\n    let key: string | null = null;\n    if(snapshot) { key = snapshot.key; }\n    return { type: event, payload: snapshot, prevKey, key };\n  })\n  // Ensures subscribe on observable is async. This handles\n  // a quirk in the SDK where on/once callbacks can happen\n  // synchronously.\n  .delay(0); \n  return observeOn.call(ref$, new ZoneScheduler(Zone.current));\n}\n"]}