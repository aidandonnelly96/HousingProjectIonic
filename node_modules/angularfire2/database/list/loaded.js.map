{"version":3,"sources":["../../../../src/database/list/loaded.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,OAAO,EAAE,MAAM,uBAAuB,CAAC;AAChD,OAAO,EAAE,eAAe,EAAE,MAAM,oBAAoB,CAAC;AAGrD,OAAO,6BAA6B,CAAC;AACrC,OAAO,kCAAkC,CAAC;AAC1C,OAAO,uBAAuB,CAAC;AAW/B,MAAM,8BAA8B,KAAoB;IACtD,MAAM,CAAC,UAAC,MAAqB,IAAK,OAAA,qBAAqB,CAAC,KAAK,EAAE,MAAM,CAAC,EAApC,CAAoC,CAAC;AACzE,CAAC;AAOD,MAAM,qBAAqB,KAAoB;IAI7C,MAAM,CAAC,OAAO,CAAC,KAAK,EAAE,OAAO,CAAC;SAC7B,GAAG,CAAC,UAAA,IAAI;QAEP,IAAI,aAAa,CAAC;QAElB,IAAI,CAAC,OAAQ,CAAC,OAAO,CAAC,UAAA,KAAK;YACzB,aAAa,GAAG,KAAK,CAAC,GAAG,CAAC;YAAC,MAAM,CAAC,KAAK,CAAC;QAC1C,CAAC,CAAC,CAAC;QAEH,MAAM,CAAC,EAAE,IAAI,MAAA,EAAE,aAAa,eAAA,EAAE,CAAC;IACjC,CAAC,CAAC,CAAC;AACL,CAAC;AAED,MAAM,wBAAwB,KAAoB,EAAE,OAAqC;IACvF,IAAM,OAAO,GAAG,UAAU,CAAC,KAAK,CAAC,CAAC;IAClC,MAAM,CAAC,OAAO;SACX,cAAc,CAAC,OAAO,CAAC;SAGvB,GAAG,CAAC,UAAC,EAAiB;YAAhB,cAAM,EAAE,eAAO;QAEpB,IAAI,aAAa,GAAG,MAAM,CAAC,aAAa,CAAC;QAEzC,IAAM,UAAU,GAAG,OAAO,CAAC,GAAG,CAAC,UAAA,IAAI,IAAI,OAAA,IAAI,CAAC,GAAG,EAAR,CAAQ,CAAC,CAAC;QACjD,MAAM,CAAC,EAAE,OAAO,SAAA,EAAE,aAAa,eAAA,EAAE,UAAU,YAAA,EAAE,CAAA;IAC/C,CAAC,CAAC;SAID,SAAS,CAAC,UAAA,IAAI,IAAI,OAAA,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,IAAI,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC,EAAlD,CAAkD,CAAC;SAGrE,GAAG,CAAC,UAAA,IAAI,IAAI,OAAA,IAAI,CAAC,OAAO,EAAZ,CAAY,CAAC,CAAC;AAC/B,CAAC;AAED,MAAM,gCAAgC,KAAoB,EAAE,MAAqB;IAC/E,IAAM,YAAY,GAAG,eAAe,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;IACpD,MAAM,CAAC,aAAa,CAAC,KAAK,EAAE,YAAY,CAAC,CAAC;AAC5C,CAAC","file":"loaded.js","sourceRoot":"","sourcesContent":["import { DatabaseQuery, ChildEvent, DatabaseSnapshot, AngularFireAction, SnapshotAction } from '../interfaces';\nimport { fromRef } from '../observable/fromRef';\nimport { snapshotChanges } from './snapshot-changes';\nimport { database } from 'firebase/app';\nimport { Observable } from 'rxjs/Observable';\nimport 'rxjs/add/operator/skipWhile';\nimport 'rxjs/add/operator/withLatestFrom';\nimport 'rxjs/add/operator/map';\n\n/**\n * Creates a function that creates a \"loaded observable\".\n * A \"loaded observable\" waits until the final child emissions are\n * complete and match the last key in the dataset before emitting\n * the \"whole\" array. Realtime updates can continue to apply to the\n * array, but by leveraging skipWhile, we wait until the first value\n * set is \"whole\" so the user is inundated with child_added updates.\n * @param query \n */\nexport function createLoadedChanges(query: DatabaseQuery): (events?: ChildEvent[]) => Observable<SnapshotAction[]> {\n  return (events?: ChildEvent[]) => loadedSnapshotChanges(query, events);\n}\n\nexport interface LoadedMetadata {\n  data: AngularFireAction<database.DataSnapshot | null>;\n  lastKeyToLoad: any;\n}\n\nexport function loadedData(query: DatabaseQuery): Observable<LoadedMetadata> {\n  // Create an observable of loaded values to retrieve the\n  // known dataset. This will allow us to know what key to\n  // emit the \"whole\" array at when listening for child events.\n  return fromRef(query, 'value')\n  .map(data => {\n    // Store the last key in the data set\n    let lastKeyToLoad;\n    // Loop through loaded dataset to find the last key\n    data.payload!.forEach(child => {\n      lastKeyToLoad = child.key; return false;\n    });\n    // return data set and the current last key loaded\n    return { data, lastKeyToLoad };\n  });\n}\n\nexport function waitForLoaded(query: DatabaseQuery, action$: Observable<SnapshotAction[]>) {\n  const loaded$ = loadedData(query);\n  return loaded$\n    .withLatestFrom(action$)\n    // Get the latest values from the \"loaded\" and \"child\" datasets\n    // We can use both datasets to form an array of the latest values.\n    .map(([loaded, actions]) => {\n      // Store the last key in the data set\n      let lastKeyToLoad = loaded.lastKeyToLoad;\n      // Store all child keys loaded at this point\n      const loadedKeys = actions.map(snap => snap.key);\n      return { actions, lastKeyToLoad, loadedKeys }\n    })\n    // This is the magical part, only emit when the last load key\n    // in the dataset has been loaded by a child event. At this point\n    // we can assume the dataset is \"whole\".\n    .skipWhile(meta => meta.loadedKeys.indexOf(meta.lastKeyToLoad) === -1)\n    // Pluck off the meta data because the user only cares\n    // to iterate through the snapshots\n    .map(meta => meta.actions);  \n}\n\nexport function loadedSnapshotChanges(query: DatabaseQuery, events?: ChildEvent[]): Observable<SnapshotAction[]> {\n  const snapChanges$ = snapshotChanges(query, events);\n  return waitForLoaded(query, snapChanges$);\n}\n"]}